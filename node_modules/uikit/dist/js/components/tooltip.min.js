/*! UIkit 3.15.6 | https://www.getuikit.com | (c) 2014 - 2022 YOOtheme | MIT License */(function(s,g){typeof exports=="object"&&typeof module<"u"?module.exports=g(require("uikit-util")):typeof define=="function"&&define.amd?define("uikittooltip",["uikit-util"],g):(s=typeof globalThis<"u"?globalThis:s||self,s.UIkitTooltip=g(s.UIkit.util))})(this,function(s){"use strict";var g={props:{container:Boolean},data:{container:!0},computed:{container(t){let{container:o}=t;return o===!0&&this.$container||o&&s.$(o)}}},E={props:{cls:Boolean,animation:"list",duration:Number,velocity:Number,origin:String,transition:String},data:{cls:!1,animation:[!1],duration:200,velocity:.2,origin:!1,transition:"ease",clsEnter:"uk-togglabe-enter",clsLeave:"uk-togglabe-leave"},computed:{hasAnimation(t){let{animation:o}=t;return!!o[0]},hasTransition(t){let{animation:o}=t;return["slide","reveal"].some(e=>s.startsWith(o[0],e))}},methods:{toggleElement(t,o,e){return new Promise(n=>Promise.all(s.toNodes(t).map(i=>{const r=s.isBoolean(o)?o:!this.isToggled(i);if(!s.trigger(i,"before"+(r?"show":"hide"),[this]))return Promise.reject();const h=(s.isFunction(e)?e:e===!1||!this.hasAnimation?S:this.hasTransition?B:I)(i,r,this),c=r?this.clsEnter:this.clsLeave;s.addClass(i,c),s.trigger(i,r?"show":"hide",[this]);const a=()=>{s.removeClass(i,c),s.trigger(i,r?"shown":"hidden",[this])};return h?h.then(a,()=>(s.removeClass(i,c),Promise.reject())):a()})).then(n,s.noop))},isToggled(t){return t===void 0&&(t=this.$el),[t]=s.toNodes(t),s.hasClass(t,this.clsEnter)?!0:s.hasClass(t,this.clsLeave)?!1:this.cls?s.hasClass(t,this.cls.split(" ")[0]):s.isVisible(t)},_toggle(t,o){if(!t)return;o=Boolean(o);let e;this.cls?(e=s.includes(this.cls," ")||o!==s.hasClass(t,this.cls),e&&s.toggleClass(t,this.cls,s.includes(this.cls," ")?void 0:o)):(e=o===t.hidden,e&&(t.hidden=!o)),s.$$("[autofocus]",t).some(n=>s.isVisible(n)?n.focus()||!0:n.blur()),e&&s.trigger(t,"toggled",[o,this])}}};function S(t,o,e){let{_toggle:n}=e;return s.Animation.cancel(t),s.Transition.cancel(t),n(t,o)}async function B(t,o,e){var n;let{animation:i,duration:r,velocity:h,transition:c,_toggle:a}=e;const[f="reveal",l="top"]=((n=i[0])==null?void 0:n.split("-"))||[],u=[["left","right"],["top","bottom"]],y=u[s.includes(u[0],l)?0:1],x=y[1]===l,v=["width","height"][u.indexOf(y)],p="margin-"+y[0],b="margin-"+l;let m=s.dimensions(t)[v];const N=s.Transition.inProgress(t);await s.Transition.cancel(t),o&&a(t,!0);const j=Object.fromEntries(["padding","border","width","height","minWidth","minHeight","overflowY","overflowX",p,b].map(_=>[_,t.style[_]])),w=s.dimensions(t),P=s.toFloat(s.css(t,p)),A=s.toFloat(s.css(t,b)),d=w[v]+A;!N&&!o&&(m+=A);const[T]=s.wrapInner(t,"<div>");s.css(T,{boxSizing:"border-box",height:w.height,width:w.width,...s.css(t,["overflow","padding","borderTop","borderRight","borderBottom","borderLeft","borderImage",b])}),s.css(t,{padding:0,border:0,minWidth:0,minHeight:0,[b]:0,width:w.width,height:w.height,overflow:"hidden",[v]:m});const C=m/d;r=(h*d+r)*(o?1-C:C);const O={[v]:o?d:0};x&&(s.css(t,p,d-m+P),O[p]=o?P:d+P),!x^f==="reveal"&&(s.css(T,p,-d+m),s.Transition.start(T,{[p]:o?0:-d},r,c));try{await s.Transition.start(t,O,r,c)}finally{s.css(t,j),s.unwrap(T.firstChild),o||a(t,!1)}}function I(t,o,e){s.Animation.cancel(t);const{animation:n,duration:i,_toggle:r}=e;return o?(r(t,!0),s.Animation.in(t,n[0],i,e.origin)):s.Animation.out(t,n[1]||n[0],i,e.origin).then(()=>r(t,!1))}var L={props:{pos:String,offset:null,flip:Boolean,shift:Boolean,inset:Boolean},data:{pos:"bottom-"+(s.isRtl?"right":"left"),offset:!1,flip:!0,shift:!0,inset:!1},connected(){this.pos=this.$props.pos.split("-").concat("center").slice(0,2),[this.dir,this.align]=this.pos,this.axis=s.includes(["top","bottom"],this.dir)?"y":"x"},methods:{positionAt(t,o,e){let n=[this.getPositionOffset(t),this.getShiftOffset(t)];const i=[this.flip&&"flip",this.shift&&"shift"],r={element:[this.inset?this.dir:s.flipPosition(this.dir),this.align],target:[this.dir,this.align]};if(this.axis==="y"){for(const l in r)r[l].reverse();n.reverse(),i.reverse()}const[h]=s.scrollParents(t,/auto|scroll/),{scrollTop:c,scrollLeft:a}=h,f=s.dimensions(t);s.css(t,{top:-f.height,left:-f.width}),s.positionAt(t,o,{attach:r,offset:n,boundary:e,placement:i,viewportOffset:this.getViewportOffset(t)}),h.scrollTop=c,h.scrollLeft=a},getPositionOffset(t){return s.toPx(this.offset===!1?s.css(t,"--uk-position-offset"):this.offset,this.axis==="x"?"width":"height",t)*(s.includes(["left","top"],this.dir)?-1:1)*(this.inset?-1:1)},getShiftOffset(t){return this.align==="center"?0:s.toPx(s.css(t,"--uk-position-shift-offset"),this.axis==="y"?"width":"height",t)*(s.includes(["left","top"],this.align)?1:-1)},getViewportOffset(t){return s.toPx(s.css(t,"--uk-position-viewport-offset"))}}},$={mixins:[g,E,L],args:"title",props:{delay:Number,title:String},data:{pos:"top",title:"",delay:0,animation:["uk-animation-scale-up"],duration:100,cls:"uk-active"},beforeConnect(){this._hasTitle=s.hasAttr(this.$el,"title"),s.attr(this.$el,"title",""),this.updateAria(!1),D(this.$el)},disconnected(){this.hide(),s.attr(this.$el,"title",this._hasTitle?this.title:null)},methods:{show(){this.isToggled(this.tooltip||null)||!this.title||(this._unbind=s.once(document,"show keydown "+s.pointerDown,this.hide,!1,t=>t.type===s.pointerDown&&!s.within(t.target,this.$el)||t.type==="keydown"&&t.keyCode===27||t.type==="show"&&t.detail[0]!==this&&t.detail[0].$name===this.$name),clearTimeout(this.showTimer),this.showTimer=setTimeout(this._show,this.delay))},async hide(){s.matches(this.$el,"input:focus")||(clearTimeout(this.showTimer),this.isToggled(this.tooltip||null)&&(await this.toggleElement(this.tooltip,!1,!1),s.remove(this.tooltip),this.tooltip=null,this._unbind()))},_show(){this.tooltip=s.append(this.container,'<div class="uk-'+this.$options.name+'"> <div class="uk-'+this.$options.name+'-inner">'+this.title+"</div> </div>"),s.on(this.tooltip,"toggled",(t,o)=>{if(this.updateAria(o),!o)return;this.positionAt(this.tooltip,this.$el);const[e,n]=F(this.tooltip,this.$el,this.pos);this.origin=this.axis==="y"?s.flipPosition(e)+"-"+n:n+"-"+s.flipPosition(e)}),this.toggleElement(this.tooltip,!0)},updateAria(t){s.attr(this.$el,"aria-expanded",t)}},events:{focus:"show",blur:"hide",[s.pointerEnter+" "+s.pointerLeave](t){s.isTouch(t)||this[t.type===s.pointerEnter?"show":"hide"]()},[s.pointerDown](t){s.isTouch(t)&&this.show()}}};function D(t){s.isFocusable(t)||s.attr(t,"tabindex","0")}function F(t,o,e){let[n,i]=e;const r=s.offset(t),h=s.offset(o),c=[["left","right"],["top","bottom"]];for(const f of c){if(r[f[0]]>=h[f[1]]){n=f[1];break}if(r[f[1]]<=h[f[0]]){n=f[0];break}}const a=s.includes(c[0],n)?c[1]:c[0];return r[a[0]]===h[a[0]]?i=a[0]:r[a[1]]===h[a[1]]?i=a[1]:i="center",[n,i]}return typeof window<"u"&&window.UIkit&&window.UIkit.component("tooltip",$),$});
